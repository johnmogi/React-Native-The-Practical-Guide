1
00:00:02,280 --> 00:00:05,290
私たちは多くをカバーしており、ここでは多くの名前を変更しました。

2
00:00:05,550 --> 00:00:14,260
&nbsp;

3
00:00:14,260 --> 00:00:23,290
&nbsp;

4
00:00:23,290 --> 00:00:26,380
しかし、私たちが実際に名前を変更したいのであれば、ここの人のコンポーネントでは、実際には数値型の要素があり、テキスト型の通常の入力要素があり、それは自動的に閉じるべきです。

5
00:00:26,470 --> 00:00:34,680
ここで何かを入力するたびに、ここで入力したものを死んだ人の新しい名前として使用したいと考えています。

6
00:00:34,690 --> 00:00:43,970
私たちはchange onの特別イベントを聞くことができます。入力の値が変更されるたびにonchangeが発生します。

7
00:00:44,650 --> 00:00:53,440
そして、ここで私は私のアプリの追跡ファイルから渡す必要があるいくつかのメソッドを実行したくないです。

8
00:00:53,440 --> 00:01:01,810
私はそのスイッチネームハンドラを得て、それをそのまま残し、代わりに新しいハンドラをすべて名前と名前を変更したハンドラを追加します。

9
00:01:01,810 --> 00:01:04,950
&nbsp;

10
00:01:05,380 --> 00:01:08,680
ここでイベントオブジェクトを取得する予定です。

11
00:01:08,680 --> 00:01:14,710
私たちはこれまでこれを使っていませんでしたが、そこではまだ状態を変えたいと思っています。

12
00:01:14,820 --> 00:01:18,880
もちろん理論的には変更したいと思っています。

13
00:01:18,880 --> 00:01:24,250
それは私達がこれをタイプする人の名前または名前であるか？

14
00:01:24,250 --> 00:01:31,450
これは、動的要素のリストを正しくレンダリングする方法を学ぶと、コースの後半で行うことになります。

15
00:01:31,480 --> 00:01:32,560
&nbsp;

16
00:01:32,560 --> 00:01:36,340
だから私はここでいつもManueの名前を変更します。

17
00:01:36,580 --> 00:01:42,220
だからマックスはマックスに残り、ステファニーの男性は26歳にしておくべきだろう。

18
00:01:42,340 --> 00:01:50,410
しかし、あなたが名前を変更する必要がある人は、私がこのタイプのインスタンスを再入力するかどうかは関係ありません。

19
00:01:50,470 --> 00:01:53,190
&nbsp;

20
00:01:53,230 --> 00:01:56,490
ここで私はU曲げを得るでしょう。

21
00:01:56,620 --> 00:02:03,910
&nbsp;

22
00:02:03,910 --> 00:02:11,280
そして、あなたがjavascriptのイベントを知っているかもしれないので、このイベントはおそらくターゲットが良い名前値のために作っていないターゲットを持っていますが、ターゲットは私たちが入力した入力でなければなりません。

23
00:02:11,470 --> 00:02:17,750
実際には、ユーザーが入力した値のプロパティも持っている必要があります。したがって、これによりnameの値が更新されます。

24
00:02:17,770 --> 00:02:23,180
&nbsp;

25
00:02:23,320 --> 00:02:27,580
したがって、イベントターゲット値は、私がマニュアルの新しい名前として割り当てるものです。

26
00:02:27,640 --> 00:02:35,320
もう一度、どのコンポーネントの入力に名前が変更されたかを入力しても、ハンドラは問題ありません。

27
00:02:35,320 --> 00:02:36,640
&nbsp;

28
00:02:36,640 --> 00:02:42,680
今私はそこからそれにアクセスできるようにするためにこれをコンポーネントに渡す必要があります。

29
00:02:43,090 --> 00:02:47,830
私はメニューを変えることができるので、メニューの人に渡すだけです。

30
00:02:47,920 --> 00:02:50,730
もちろん、他のコースにも渡すことができます。

31
00:02:51,010 --> 00:03:01,870
ここでは、単にこの名前を変更し、この名前をハンドラに変更したハンドラを、同じロジックに従って、人の中でクリックイベントを転送するように要求して渡します。

32
00:03:01,890 --> 00:03:05,460
&nbsp;

33
00:03:05,500 --> 00:03:14,500
私は今この変更されたプロパティにアクセスし、ここで変更されたpropの呼び出しを呼び出すか、かっこを追加せず単に参照を渡します。

34
00:03:14,500 --> 00:03:18,450
&nbsp;

35
00:03:18,580 --> 00:03:25,970
そして、これは実際にはこの名前がハンドラを変更したと宣言したメソッドを指しています。

36
00:03:26,540 --> 00:03:33,410
イベントオブジェクトは、実際には通常のjavascriptのように反応して自動的に渡されます。

37
00:03:33,430 --> 00:03:36,370
デフォルトでは、どこにイベントオブジェクトへのアクセス権がありますか？

38
00:03:37,130 --> 00:03:40,050
それを保存して、何が起こるか見てみましょう。

39
00:03:40,130 --> 00:03:46,090
&nbsp;

40
00:03:46,100 --> 00:03:53,650
私たちはすべてのコンポーネントの下に入力を持っていますが、ほとんどの場合、私が入力したすべてのキーストロークで表示されることを知っている人のために入力すると何も起こりません。名前変更されたハンドラへの参照を保持しているStiefelイベントオブジェクトを使用して、入力要素であるターゲットを抽出し、次に入力したターゲットの値を抽出しました。

41
00:03:53,690 --> 00:04:01,610
&nbsp;

42
00:04:01,850 --> 00:04:07,820
&nbsp;

43
00:04:07,820 --> 00:04:10,970
&nbsp;

44
00:04:10,970 --> 00:04:16,850
&nbsp;

45
00:04:16,850 --> 00:04:22,430
&nbsp;

46
00:04:22,430 --> 00:04:26,990
これは実際には動的に何かを動的に更新してイベントを動的に呼び出す方法と、私が言うべきイベント参照やメソッド参照を渡すような前に学ぶことを使う方法ですが、入力をどのように処理できるかがわかります。

47
00:04:27,530 --> 00:04:36,820
今度は、最初から入力の右側にある名前の現在の値を見るといいでしょう。

48
00:04:37,130 --> 00:04:43,760
したがって、我々は基本的に双方向のバインドを設定して、その変更を伝播して状態を更新できるようにしたいとします。

49
00:04:43,760 --> 00:04:46,220
&nbsp;

50
00:04:46,430 --> 00:04:49,890
しかし、我々はまた、当初から現在の状態を見たいと思っています。

51
00:04:50,390 --> 00:04:57,070
これを行うために私はpropの名前と等しい値を設定することができます。

52
00:04:57,080 --> 00:04:59,210
これは結局のところ名前です。

53
00:04:59,210 --> 00:05:02,160
そして今、我々は独自の双方向バインディングを設定しています。

54
00:05:02,270 --> 00:05:09,350
&nbsp;

55
00:05:09,350 --> 00:05:17,030
&nbsp;

56
00:05:17,030 --> 00:05:20,510
変更を聞くと、最後にchangeメソッドが呼び出されます。これは、名前変更ハンドラを参照して状態を更新し、名前と年齢の人に状態を渡し、名前を入力の値として出力します。

57
00:05:20,510 --> 00:05:24,800
これにより、最初からその価値を示すことができます。

58
00:05:25,070 --> 00:05:31,190
&nbsp;

59
00:05:31,190 --> 00:05:38,910
&nbsp;

60
00:05:38,910 --> 00:05:43,310
そして、ここで私は実際に警告を発するのは理論的には理にかなっています。なぜなら、onchangeハンドラなしで値の小道具を提供すると、実際に問題にぶつかります。

61
00:05:43,310 --> 00:05:45,730
したがって、入力をロックダウンします。

62
00:05:45,770 --> 00:05:51,800
私はonchangeを削除すればそれを示すことができました。今でも値は見ていますが、入力すれば何も起こりません。変更を処理していないので入力できません。

63
00:05:51,800 --> 00:05:55,550
&nbsp;

64
00:05:55,670 --> 00:06:00,920
だから私たちは常に既存の名前でタイプしようとするものを上書きします。

65
00:06:01,340 --> 00:06:08,320
私がonchangeを再導入しても、エラーはここにとどまりますが、これは単に誤ったアラームです。

66
00:06:08,510 --> 00:06:14,180
あなたが明らかにわかるように、私は自分の変更を処理できるAhanだからタイプすることができます。

67
00:06:14,180 --> 00:06:19,880
私の状態を更新して私の小道具を更新し、私の変更もここに反映されます。

68
00:06:20,060 --> 00:06:25,230
だから私たちは働く2つの方法バインディングを持っており、私たちはその名前を動的に変更することができます。

69
00:06:25,340 --> 00:06:31,730
私たちはyabberの入力とSukant型のロジックを設定していないので、ここではこれらの名前をそこで更新することはできないので、マニュアルだけを念頭に置いてください。

70
00:06:31,760 --> 00:06:35,690
&nbsp;

71
00:06:35,840 --> 00:06:40,630
そして、それはおそらく、Ashberyのこれらの入力についてここで不平を言っている理由です。

72
00:06:40,860 --> 00:06:47,600
今のところ、これを無視することはできますが、エレメントのリストを動的にレンダリングするより良い方法があれば、これを改善します。

73
00:06:47,690 --> 00:06:49,410
&nbsp;
