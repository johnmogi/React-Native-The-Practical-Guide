1
00:00:02,190 --> 00:00:06,300
最後の講義では人を取り除くことにしました。

2
00:00:06,300 --> 00:00:11,830
私たちは、状態を更新し、人のインデックスを使用して削除したい1つの要素を削除して、状態のすべての人にアクセスすることによってこれを行いました。

3
00:00:11,830 --> 00:00:16,320
&nbsp;

4
00:00:16,320 --> 00:00:23,700
このアプローチの欠点は、javascriptのオブジェクトと配列が参照型であることです。

5
00:00:23,700 --> 00:00:31,860
だから私がここで私の状態から人を取得すると、私は実際に元の状態に反応して管理されている元の人のオブジェクトへのポインタを取得します。

6
00:00:31,860 --> 00:00:35,370
&nbsp;

7
00:00:35,370 --> 00:00:43,560
私はそれをここにスプライスして、私はすでにこの元のデータを突き詰めてしまえば、エラーを投げずに動作したら本当にやるべき方法ではないと言うべきです。

8
00:00:43,560 --> 00:00:47,180
&nbsp;

9
00:00:47,190 --> 00:00:52,850
これは予測不可能なアプリにつながり、間違いなく悪い習慣です。

10
00:00:52,920 --> 00:01:00,810
&nbsp;

11
00:01:00,810 --> 00:01:08,430
&nbsp;

12
00:01:08,430 --> 00:01:10,950
良い方法は、パーシスタンス配列を操作する前にそのコピーを作成することです。単純な方法は、引数なしでスライスメソッドsliceを呼び出すだけで、完全な配列をコピーして新しい配列を返して、ここに格納します。

13
00:01:11,190 --> 00:01:18,570
そして、この新しいものを安全に編集して、新しいアレイで状態を更新することができます。

14
00:01:19,400 --> 00:01:28,950
&nbsp;

15
00:01:28,950 --> 00:01:37,400
&nbsp;

16
00:01:37,580 --> 00:01:39,540
このアプローチに代わる方法は、スプレッド演算子を6つの特徴として使用することです。単純に小銭を新しい配列に設定することができます。この新しい配列は、自由ドットが奇妙に見えるかもしれないスプレッド演算子を使用できるようになりましたが、これはjavascriptです。

17
00:01:39,540 --> 00:01:43,650
オペレーター刑務所の状態をどこまで知ることができますか？

18
00:01:43,700 --> 00:01:50,180
&nbsp;

19
00:01:50,180 --> 00:01:56,920
&nbsp;

20
00:01:57,170 --> 00:01:59,480
これは配列の要素を配列として要素のリストに展開して単純にこの配列に追加したもので、古い配列のオブジェクトではなく配列自体ではなく新しい配列になっています。

21
00:01:59,720 --> 00:02:02,720
これは基本的にスライスアプローチと同じです。

22
00:02:02,720 --> 00:02:04,350
好きなものを使いましょう。

23
00:02:04,490 --> 00:02:11,060
これはより現代的なものであり、この読書がコースのためにより頻繁に動作するのを見るでしょう。

24
00:02:11,080 --> 00:02:16,050
これで以前と同じ動作が得られ、エラーメッセージを修正しませんでした。

25
00:02:16,060 --> 00:02:21,790
以前と同じように動作しますが、状態を更新する方が良い方法だと言えます。

26
00:02:21,800 --> 00:02:28,160
あなたは常に元の状態を変更することなく、不変の方法で状態を更新する必要があります。最初にコピー変更債務を作成し、次にその状態で状態を更新します。

27
00:02:28,430 --> 00:02:33,780
&nbsp;

28
00:02:33,830 --> 00:02:37,590
それでも、私たちのリストについて改善できるはずのものがあります。
