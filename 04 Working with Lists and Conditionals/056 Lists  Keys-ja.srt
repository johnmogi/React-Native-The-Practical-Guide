1
00:00:02,850 --> 00:00:08,370
&nbsp;

2
00:00:08,370 --> 00:00:15,390
&nbsp;

3
00:00:15,390 --> 00:00:22,320
&nbsp;

4
00:00:22,320 --> 00:00:29,190
&nbsp;

5
00:00:29,190 --> 00:00:31,540
すでにいくつかの作業をリストに入れておき、要素のインデックスを利用してコードを実行するなどして改善しました。実際にどの要素が実行されているかを考慮に入れています。 Proppというキーを見落としているキーのアプローチを取っているのは、実際にはデータのリストをレンダリングするときに追加すべき重要なプロパティです。そのため、Riakはそうするように指示しています。

6
00:00:31,920 --> 00:00:35,130
私たちは、個人の主要な財産を指定していない。

7
00:00:35,130 --> 00:00:41,970
実際には、カスタムのコンポーネントか、リストを使ってレンダリングするデフォルトのHVM要素かどうかにかかわらず、要素の再検出が期待する既定のプロパティです。

8
00:00:42,330 --> 00:00:47,210
&nbsp;

9
00:00:47,220 --> 00:00:57,350
したがって、基本的に配列をJ要素としてx要素にマッピングすることによって、Diskiプロパティはリストを効率的に更新するのに役立ちます。

10
00:00:57,360 --> 00:01:00,980
ここで、リストから要素を削除する場合を考えてみましょう。

11
00:01:00,990 --> 00:01:02,650
もちろんそれは動作します。

12
00:01:02,730 --> 00:01:09,420
&nbsp;

13
00:01:09,420 --> 00:01:15,510
&nbsp;

14
00:01:15,510 --> 00:01:17,910
しかし、背後にあるReacは、実際にDom全体で調整する必要があるものを見つけ出す必要があります。コースの特定のセクションでRe-actが正確に何をするのかについては、Wheroが簡単に説明します。

15
00:01:17,910 --> 00:01:24,380
しかし基本的には、Wordle

16
00:01:24,390 --> 00:01:31,920
Domと呼ばれるものがあり、それはレンダリングされるものと比較されます。今すぐレンダリングメソッドを呼び出す場合、または実際にレンダリングメソッドの結果を使って実際のDomを以前のDomこれは、基本的に過去のこの未来の圧縮とリストのためのものです。

17
00:01:31,920 --> 00:01:37,380
&nbsp;

18
00:01:37,380 --> 00:01:40,860
&nbsp;

19
00:01:40,860 --> 00:01:46,180
もちろん、どの要素が変わったのかを知る必要があり、反応は人間ではありません。

20
00:01:46,200 --> 00:01:52,260
それは、私たちがしているように、私が誤ってクリックした異なる名前のレンダリングされた3つの別個の要素を持っていることをはっきりとわかりません。

21
00:01:52,860 --> 00:01:54,780
&nbsp;

22
00:01:54,780 --> 00:02:00,740
だから、これはMacのメニューであり、反応するSteffanieは人のコンポーネントがたくさんあり、それを深く調べることはないということは分かりません。

23
00:02:01,170 --> 00:02:03,300
&nbsp;

24
00:02:03,300 --> 00:02:05,170
それは超効率的ではありません。

25
00:02:05,670 --> 00:02:08,700
だから、デフォルトではリエラだけがリストの下にあります。

26
00:02:08,700 --> 00:02:11,790
長いリストの場合、これは非常に非効率的です。

27
00:02:11,790 --> 00:02:17,040
&nbsp;

28
00:02:17,040 --> 00:02:24,720
そこでは、個々の要素を追跡するために反応反応を可能にするためのキーを割り当てる必要があります。異なる要素間で比較して、変更された要素と変更されなかった要素を明確に区別できます。

29
00:02:24,720 --> 00:02:26,800
&nbsp;

30
00:02:26,910 --> 00:02:31,680
そこで彼らは、リスト全体ではなく変更された手直しされた要素だけを追加しました。

31
00:02:32,040 --> 00:02:38,870
だから私たちはキーを割り当て、今ここで独特な何を割り当てるのでしょうか？

32
00:02:39,180 --> 00:02:45,120
通常は、データベースなどから取得した場合は、要素に関する考え方があります。

33
00:02:45,120 --> 00:02:45,790
&nbsp;

34
00:02:45,810 --> 00:02:53,370
IDや他の固有の識別子を持っている可能性が高く、あなたの名前は一意であるかもしれませんが、それは必ずしも保証されません。

35
00:02:53,370 --> 00:02:56,250
&nbsp;

36
00:02:56,250 --> 00:03:02,340
だから私たちができることは、すべてのインデックスが変更された後に配列のすべての要素が変更されるため、インデックスを使用できるということです。

37
00:03:02,340 --> 00:03:02,630
&nbsp;

38
00:03:02,630 --> 00:03:03,210
右。

39
00:03:03,450 --> 00:03:04,110
そのとおり。

40
00:03:04,110 --> 00:03:06,920
しかし、インデックスもリスト自体の一部です。

41
00:03:07,020 --> 00:03:11,160
リストが変更されると、すべての要素が新しいインデックスを受け取ります。

42
00:03:11,160 --> 00:03:13,740
少なくとも変更後のすべての要素。

43
00:03:13,740 --> 00:03:19,890
最終的には良いキーではないので、本当に反応するのに役立ちませんので、一意の識別子を実際に試してください。

44
00:03:19,890 --> 00:03:21,010
&nbsp;

45
00:03:21,240 --> 00:03:26,530
そしてもう一度これはちょうどダミーデータですDatorここで私は単に実データにIDを追加します。

46
00:03:26,550 --> 00:03:32,380
あなたはそのようなID IDを持っている可能性は高いですが、数字でなくても一意である可能性があります。

47
00:03:32,460 --> 00:03:37,650
ここで私はちょうどいくつかのユニークなIDを取得するために私のキーボードを叩いています。

48
00:03:37,650 --> 00:03:40,040
今ではそれを使うことができます。

49
00:03:40,050 --> 00:03:48,240
すべての要素にユニークなキーがあることを確認して、未来の要素を過去の要素と比較し、更新が必要な休止場所までしか比較できないようにするには、個人IDが必要です。

50
00:03:48,240 --> 00:03:54,790
&nbsp;

51
00:03:55,020 --> 00:04:01,680
今、私たちがこの人物とターゲット人物を積み戻して、重要な警告が消えたら、以前と同じ行動を取って、それを調べてサダムをどのように更新しているか見ることができます。

52
00:04:01,680 --> 00:04:06,230
&nbsp;

53
00:04:06,270 --> 00:04:12,390
しかし、現場の裏側では、これをもっと効率的なやり方で行うことができるようになりました。もちろん、これは非常に重要です。
