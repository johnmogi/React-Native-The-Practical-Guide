1
00:00:01,990 --> 00:00:08,480
&nbsp;

2
00:00:08,480 --> 00:00:13,970
&nbsp;

3
00:00:13,970 --> 00:00:19,510
私たちが多くの機能を追加し、そのキーについて学んでいることを知ってください。このアプリケーションでは、もう少し詳しく知りたいと思います。その値を入力として返します。

4
00:00:19,670 --> 00:00:25,290
最終的には、ここで入力すると、これを入力するユーザーの名前にすぎません。

5
00:00:25,310 --> 00:00:31,280
リストをレンダリングし、本当に動的なコンテンツを作成したので、最終的にこれを本当に動的な方法で設定することができます。

6
00:00:31,280 --> 00:00:31,950
&nbsp;

7
00:00:32,150 --> 00:00:38,830
ですから、何らかのイベントリスナまたは状態を正しく更新するメソッドを指すこの変更プロパティを提供するだけです。

8
00:00:38,830 --> 00:00:42,850
&nbsp;

9
00:00:42,920 --> 00:00:47,750
だから、あなたは変えられました。そして今私たちは何か方法を指摘する必要があります。

10
00:00:47,990 --> 00:00:51,700
私たちはハンドラの名前を変更しました。

11
00:00:51,980 --> 00:00:54,820
だからここでそれを使いましょう。

12
00:00:55,130 --> 00:00:57,870
名前を変更したハンドラを指してみましょう。

13
00:00:58,040 --> 00:01:05,270
そして、今ここでこの名前変更ハンドラと2つの情報を取得して、イベントターゲット値にアクセスできるようにする必要があります。

14
00:01:05,330 --> 00:01:07,490
&nbsp;

15
00:01:07,490 --> 00:01:12,660
だからユーザーが何を入力したが、私はまた2番目の入力を期待しています。

16
00:01:12,740 --> 00:01:19,120
私は、配列の更新またはインデックス付けを行うユーザのIDを取得したい。

17
00:01:19,130 --> 00:01:20,960
しかし今、私たちはIDを割り当てます。

18
00:01:20,960 --> 00:01:22,540
なぜそれを使わないの？

19
00:01:23,150 --> 00:01:30,230
したがってここでは、この関数構文を使用してデータを便利に渡します。

20
00:01:30,260 --> 00:01:37,170
ここでこの関数は、全体の関数がonchangeイベントで実行される関数です。

21
00:01:37,220 --> 00:01:40,810
イベントオブジェクトは以前と同じように取得されます。

22
00:01:40,810 --> 00:01:46,340
名前を変更したハンドラに直接関数を割り当てなかったときにそれを得ました。

23
00:01:46,340 --> 00:01:51,440
ここでは、これをここで取り上げます。これは、ここで定義するこの無名関数を実行する最初の関数なのでです。

24
00:01:51,440 --> 00:01:53,100
&nbsp;

25
00:01:53,210 --> 00:01:56,660
私はそれを名前変更ハンドラに渡すことができます。

26
00:01:56,900 --> 00:02:00,620
そして私はまたそれに人のIDを渡したいと思います。

27
00:02:00,620 --> 00:02:04,310
私たちがここの地図メソッドの中にいるので、もちろん人のIDは利用可能です。

28
00:02:04,340 --> 00:02:07,940
だから、私たちはその人に、そしてIDにはxをつけなければなりません。

29
00:02:08,600 --> 00:02:17,180
これで、状態を更新する名前変更ハンドラでその情報を使用できるようになりました。

30
00:02:17,180 --> 00:02:21,740
もちろん、私たちが入力した入力フィールドの人だけです。

31
00:02:21,770 --> 00:02:27,230
&nbsp;

32
00:02:27,230 --> 00:02:36,080
だから私たちは、その人を単一の人物にする必要があります。私たちは人の目を見開いて状態に到達し、この人を与えるデフォルトのjavascriptメソッドとしてこれらを再度呼び出すことによって、これを行うことができます。

33
00:02:36,090 --> 00:02:37,080
&nbsp;

34
00:02:37,460 --> 00:02:45,680
findインデックスを使用して配列内の要素を検索することもできますが、その要素のインデックスを取得することができます。インデックスにこの関数を直接渡すこともできます。

35
00:02:45,680 --> 00:02:48,830
&nbsp;

36
00:02:48,830 --> 00:02:55,220
&nbsp;

37
00:02:55,220 --> 00:03:02,930
私はちょうどこの代替アプローチがIDを利用していることを示したいと思います。findのインデックスは、マップされたとおりに入力として関数を取ります。マップのように、配列のすべての要素に対してこの関数を実行します。

38
00:03:02,930 --> 00:03:03,670
&nbsp;

39
00:03:03,980 --> 00:03:10,820
そこでここでは、この引数名があなた次第であるが、人は既に定数によって取り込まれている関数を実行します。

40
00:03:10,820 --> 00:03:12,940
&nbsp;

41
00:03:13,100 --> 00:03:16,940
私はこの人を取得して入力し、私は機能の本体を取得します。

42
00:03:17,240 --> 00:03:22,240
今ここの地図と違って、私はこの要素を新しいものにマップしません。

43
00:03:22,310 --> 00:03:27,200
&nbsp;

44
00:03:27,500 --> 00:03:32,810
代わりに、ここで私が探していた要素であるかどうかに関わらず、私が探していた人物または一般的に話している人物を脱調させるかどうかによって、真実か偽りかを返さなければなりません。

45
00:03:32,840 --> 00:03:34,780
今は私が探していた人です。

46
00:03:34,790 --> 00:03:36,920
P IDの場合。

47
00:03:37,130 --> 00:03:39,960
だから私は現在この一人の人を見ています。

48
00:03:39,980 --> 00:03:44,070
ここでも、この関数はすべての要素と要素に対して実行されることに注意してください。

49
00:03:44,510 --> 00:03:50,570
それがアイデアと等しいか、または等しい関数の引数として受け取る場合、trueを返します。

50
00:03:50,570 --> 00:03:51,160
&nbsp;

51
00:03:51,320 --> 00:03:58,670
そして、人物のインデックスがより良い名前である可能性があります、そのIDの等しいそれらの配列内の人物のインデックスを保持します。

52
00:03:58,670 --> 00:04:01,370
&nbsp;

53
00:04:01,370 --> 00:04:09,290
私はその後、これらの国家の人々に手を差し伸べることによって人自身を得ることができます。

54
00:04:09,290 --> 00:04:12,670
&nbsp;

55
00:04:13,160 --> 00:04:14,730
前と同じように今。

56
00:04:14,840 --> 00:04:21,830
あなたがここではjavascriptオブジェクトであることを明確に確認できるので、状態を直接変えたり、人の配列に人を入れたりしないことをお勧めします。

57
00:04:21,830 --> 00:04:25,200
&nbsp;

58
00:04:25,220 --> 00:04:32,240
&nbsp;

59
00:04:32,240 --> 00:04:38,470
&nbsp;

60
00:04:38,480 --> 00:04:40,290
今私があなたに言ったように、javascriptオブジェクトは参照型なので、ここで人に手を差し伸べるとポインタを取得するだけなので、直接ポインタを変更するべきではないので、このポインタが指す元のオブジェクトを変更します。

61
00:04:40,790 --> 00:04:51,140
だから、より良いアプローチは、このような新しいjavascriptオブジェクトを作成し、私はフェッチしているオブジェクトの前でこのスプレッド演算子を使用することです。

62
00:04:51,500 --> 00:04:53,820
&nbsp;

63
00:04:53,960 --> 00:04:59,810
配列と同じように、オブジェクトのすべてのレベルです。オブジェクトをフェッチするオブジェクトのすべてのプロパティを、ここで作成しているこの新しいOptikに配布します。

64
00:05:00,080 --> 00:05:05,870
&nbsp;

65
00:05:06,130 --> 00:05:11,940
ここでは私が使用しない別のアプローチもありますが、スプレッド演算子を使用しない代替アプローチでは、オブジェクトを使用してデフォルトのjavascript関数を割り当て、最初の引数として空のオブジェクトを渡し、

66
00:05:11,980 --> 00:05:19,000
2つ目のオブジェクトとして割り当てたいプロパティを指定します。

67
00:05:19,000 --> 00:05:25,600
&nbsp;

68
00:05:25,600 --> 00:05:27,840
&nbsp;

69
00:05:28,660 --> 00:05:30,540
あるいは、私が言うべき第二の議論。

70
00:05:30,700 --> 00:05:35,560
したがって、空のオブジェクトでオブジェクトに割り当てられた記号と、それからプロパティを取得するオブジェクトが代わりになります。

71
00:05:35,860 --> 00:05:36,980
&nbsp;

72
00:05:37,120 --> 00:05:41,920
しかし、私はこれをコメントします。なぜなら、普及した演算子のより近代的なアプローチを使用したいからです。あなたは絶対に両方を使うことができます。

73
00:05:41,920 --> 00:05:43,230
&nbsp;

74
00:05:43,240 --> 00:05:46,720
ここには良いことも悪いこともありません。

75
00:05:46,780 --> 00:05:48,700
それで、私はその人を手に入れます。

76
00:05:48,700 --> 00:05:53,790
今私はコースの人の名前を更新したいと私はコピーを持っているので、私はこれを行うことができます。

77
00:05:53,800 --> 00:06:02,500
私は元のオブジェクトを操作していないので、以前と同じようにイベントのターゲット名Suzyの値に設定することができます。

78
00:06:02,500 --> 00:06:04,500
&nbsp;

79
00:06:04,510 --> 00:06:12,300
今私はコースの配列を更新する必要があり、私はここでフェッチしたこの位置で配列を更新したいと思います。

80
00:06:12,730 --> 00:06:20,500
前と同じように、私のパーセントは、私たちがオペレーターを広めるか、スライスしなければならないのは、国民に手を差し伸べなければなりません。

81
00:06:20,710 --> 00:06:23,110
&nbsp;

82
00:06:23,500 --> 00:06:31,690
そして今私達は1つの位置でそれを更新することができます人の次の人はここで私の更新された人になるはずです。

83
00:06:31,690 --> 00:06:34,310
私はいつもここでコピーを作っています。

84
00:06:34,840 --> 00:06:44,620
これで更新された人物のIraisが得られました。これで最終的にここで状態を設定し、古い配列のコピーであるcutis

85
00:06:44,680 --> 00:06:52,360
updated個体配列を設定しました。

86
00:06:52,360 --> 00:06:55,390
&nbsp;

87
00:06:55,390 --> 00:07:01,550
多くのコードがありますが、状態を変更することなく最も効果的な方法です。

88
00:07:01,690 --> 00:07:08,650
そして今、私たちが見なければならないことを保存すれば、ここですべての名前を見る前に警告が出なくなるということです。

89
00:07:08,710 --> 00:07:10,370
&nbsp;

90
00:07:10,690 --> 00:07:17,680
ここで入力を開始し、入力が属するオブジェクトを更新します。

91
00:07:17,690 --> 00:07:21,120
今ここでは本当に柔軟なコンポーネントが得られます。

92
00:07:21,220 --> 00:07:28,600
現代の機能を有効に活用してこのリストを効率的にレンダリングし、それと効率的にやりとりする真に柔軟なアプリケーションです。

93
00:07:28,660 --> 00:07:30,910
&nbsp;

94
00:07:30,910 --> 00:07:32,120
スーパー重要。
